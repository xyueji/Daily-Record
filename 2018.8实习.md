# 2018-7-24
实习第一天，准备学习Python基础，再看一下OpenCV
## 字典特性
1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住。<br>
2）键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行。<br>
## 可更改(mutable)与不可更改(immutable)对象
在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。<br>

不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。<br>

可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。<br>

python 函数的参数传递：<br>

不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。<br>

可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响<br>

python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。<br>
在python中继承中的一些特点：<br>
1、如果在子类中需要父类的构造方法就需要显示的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看：python 子类继承父类构造函数说明。<br>
2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数<br>
3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。<br>
如果在继承元组中列了一个以上的类，那么它就被称作"多重继承" 。<br>

# 2018-7-25
昨天看完Python基础知识，OpenCV的图像读取显示及保存，OpenCV视频操作，OpenCV的绘图函数，OpenCV处理鼠标事件，OpenCV图像的基本操作。今天准备准备学习一下numpy库，继续学习OpenCV。<br>
### numpy计算：<br>
```Python
#条件判断
import numpy as np
stus_score=np.array([[80, 88], [82, 81], [84, 75], [86, 83], [75, 81]])
stus_score>80
#三目运算
np.where(stus_score<80,0,90)
```
### numpy统计计算：
```Python
import numpy as np
stus_score=np.array([[80, 88], [82, 81], [84, 75], [86, 83], [75, 81]])
#指定轴最大值amax(参数1: 数组; 参数2: axis=0/1; 0表示列1表示行)
#每一列的最大值
result=np.amax(stus_score,axis=0)
#每一行的最大值
result=np.amax(stus_score,axis=1)
#每一列的最小值
result=np.amin(stus_score,axis=0)
#每一行的最小值
result=np.amin(stus_score,axis=1)
#每一列的平均值
result=np.mean(stus_score,axis=0)
#每一行的平均值
result=np.mean(stus_score,axis=1)
#每一列的方差
result=np.std(stus_score,axis=0)
#每一行的方差
result=np.std(stus_score,axis=1)
```
### 数组运算
```Python
import numpy as np
stus_score=np.array([[80, 88], [82, 81], [84, 75], [86, 83], [75, 81]])
#数组运算
#数组与数运算
#加分
stus_score[:,0]=stus_score[:,0]+5
#减半
stus_score[:,0]=stus_score[:,0]*0.5
#数组间支持加减乘除
a = np.array([1, 2, 3, 4])
b = np.array([10, 20, 30, 40])
c = a + b
d = a - b
e = a * b
f = a / b
#矩阵运算np.dot()(非常重要)
#计算规则：(M行, N列)*(N行, Z列) = (M行, Z列)
q = np.array([[0.4], [0.6]])
result = np.dot(stus_score, q)
#矩阵拼接
#矩阵垂直拼接np.vstack((v1,v2))
v1 = [[0, 1, 2, 3, 4, 5],
      [6, 7, 8, 9, 10, 11]]
v2 = [[12, 13, 14, 15, 16, 17], 
      [18, 19, 20, 21, 22, 23]]
result = np.vstack((v1, v2))
#矩阵水平拼接np.hstack((v1,v2))
result=np.hstack((v1,v2))
#Numpy读取数据np.genfromtxt
```






