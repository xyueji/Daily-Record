# 2018-7-24
实习第一天，准备学习Python基础，再看一下OpenCV
### 字典特性
1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住。<br>
2）键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行。<br>
### 可更改(mutable)与不可更改(immutable)对象
在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。<br>

不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。<br>

可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。<br>

python 函数的参数传递：<br>

不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。<br>

可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响<br>

python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。<br>
在python中继承中的一些特点：<br>
1、如果在子类中需要父类的构造方法就需要显示的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看：python 子类继承父类构造函数说明。<br>
2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数<br>
3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。<br>
如果在继承元组中列了一个以上的类，那么它就被称作"多重继承" 。<br>

# 2018-7-25
昨天看完Python基础知识，OpenCV的图像读取显示及保存，OpenCV视频操作，OpenCV的绘图函数，OpenCV处理鼠标事件，OpenCV图像的基本操作。今天准备准备学习一下numpy库，继续学习OpenCV。<br>
### numpy计算：<br>
```Python
#条件判断
import numpy as np
stus_score=np.array([[80, 88], [82, 81], [84, 75], [86, 83], [75, 81]])
stus_score>80
#三目运算
np.where(stus_score<80,0,90)
```
### numpy统计计算：
```Python
import numpy as np
stus_score=np.array([[80, 88], [82, 81], [84, 75], [86, 83], [75, 81]])
#指定轴最大值amax(参数1: 数组; 参数2: axis=0/1; 0表示列1表示行)
#每一列的最大值
result=np.amax(stus_score,axis=0)
#每一行的最大值
result=np.amax(stus_score,axis=1)
#每一列的最小值
result=np.amin(stus_score,axis=0)
#每一行的最小值
result=np.amin(stus_score,axis=1)
#每一列的平均值
result=np.mean(stus_score,axis=0)
#每一行的平均值
result=np.mean(stus_score,axis=1)
#每一列的方差
result=np.std(stus_score,axis=0)
#每一行的方差
result=np.std(stus_score,axis=1)
```
### 数组运算
```Python
import numpy as np
stus_score=np.array([[80, 88], [82, 81], [84, 75], [86, 83], [75, 81]])
#数组运算
#数组与数运算
#加分
stus_score[:,0]=stus_score[:,0]+5
#减半
stus_score[:,0]=stus_score[:,0]*0.5
#数组间支持加减乘除
a = np.array([1, 2, 3, 4])
b = np.array([10, 20, 30, 40])
c = a + b
d = a - b
e = a * b
f = a / b
#矩阵运算np.dot()(非常重要)
#计算规则：(M行, N列)*(N行, Z列) = (M行, Z列)
q = np.array([[0.4], [0.6]])
result = np.dot(stus_score, q)
#矩阵拼接
#矩阵垂直拼接np.vstack((v1,v2))
v1 = [[0, 1, 2, 3, 4, 5],
      [6, 7, 8, 9, 10, 11]]
v2 = [[12, 13, 14, 15, 16, 17], 
      [18, 19, 20, 21, 22, 23]]
result = np.vstack((v1, v2))
#矩阵水平拼接np.hstack((v1,v2))
result=np.hstack((v1,v2))
#Numpy读取数据np.genfromtxt
```
### NumPy - 广播
1. 术语广播是指 NumPy 在算术运算期间处理不同形状的数组的能力。 对数组的算术运算通常在相应的元素上进行。 如果两个阵列具有完全相同的形状，则这些操作被无缝执行。
2. 如果两个数组的维数不相同，则元素到元素的操作是不可能的。 然而，在 NumPy 中仍然可以对形状不相似的数组进行操作，因为它拥有广播功能。 较小的数组会广播到较大数组的大小，以便使它们的形状可兼容。
如果满足以下规则，可以进行广播：
* ndim较小的数组会在前面追加一个长度为 1 的维度。
* 输出数组的每个维度的大小是输入数组该维度大小的最大值。
* 如果输入在每个维度中的大小与输出大小匹配，或其值正好为 1，则在计算中可它。
* 如果输入的某个维度大小为 1，则该维度中的第一个数据元素将用于该维度的所有计算。  
如果上述规则产生有效结果，并且满足以下条件之一，那么数组被称为可广播的。
* 数组拥有相同形状。
* 数组拥有相同的维数，每个维度拥有相同长度，或者长度为 1。
* 数组拥有极少的维度，可以在其前面追加长度为 1 的维度，使上述条件成立。






