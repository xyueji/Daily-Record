# 2018-7-24
实习第一天，准备学习Python基础，再看一下OpenCV
### 字典特性
1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住。<br>
2）键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行。<br>
### 可更改(mutable)与不可更改(immutable)对象
在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。<br>

不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。<br>

可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。<br>

python 函数的参数传递：<br>

不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。<br>

可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响<br>

python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。<br>
在python中继承中的一些特点：<br>
1、如果在子类中需要父类的构造方法就需要显示的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看：python 子类继承父类构造函数说明。<br>
2、在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数<br>
3、Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。<br>
如果在继承元组中列了一个以上的类，那么它就被称作"多重继承" 。<br>

# 2018-7-25
昨天看完Python基础知识，OpenCV的图像读取显示及保存，OpenCV视频操作，OpenCV的绘图函数，OpenCV处理鼠标事件，OpenCV图像的基本操作。今天准备准备学习一下numpy库，继续学习OpenCV。<br>
### numpy计算：<br>
```Python
#条件判断
import numpy as np
stus_score=np.array([[80, 88], [82, 81], [84, 75], [86, 83], [75, 81]])
stus_score>80
#三目运算
np.where(stus_score<80,0,90)
```
### numpy统计计算：
```Python
import numpy as np
stus_score=np.array([[80, 88], [82, 81], [84, 75], [86, 83], [75, 81]])
#指定轴最大值amax(参数1: 数组; 参数2: axis=0/1; 0表示列1表示行)
#每一列的最大值
result=np.amax(stus_score,axis=0)
#每一行的最大值
result=np.amax(stus_score,axis=1)
#每一列的最小值
result=np.amin(stus_score,axis=0)
#每一行的最小值
result=np.amin(stus_score,axis=1)
#每一列的平均值
result=np.mean(stus_score,axis=0)
#每一行的平均值
result=np.mean(stus_score,axis=1)
#每一列的方差
result=np.std(stus_score,axis=0)
#每一行的方差
result=np.std(stus_score,axis=1)
```
### 数组运算
```Python
import numpy as np
stus_score=np.array([[80, 88], [82, 81], [84, 75], [86, 83], [75, 81]])
#数组运算
#数组与数运算
#加分
stus_score[:,0]=stus_score[:,0]+5
#减半
stus_score[:,0]=stus_score[:,0]*0.5
#数组间支持加减乘除
a = np.array([1, 2, 3, 4])
b = np.array([10, 20, 30, 40])
c = a + b
d = a - b
e = a * b
f = a / b
#矩阵运算np.dot()(非常重要)
#计算规则：(M行, N列)*(N行, Z列) = (M行, Z列)
q = np.array([[0.4], [0.6]])
result = np.dot(stus_score, q)
#矩阵拼接
#矩阵垂直拼接np.vstack((v1,v2))
v1 = [[0, 1, 2, 3, 4, 5],
      [6, 7, 8, 9, 10, 11]]
v2 = [[12, 13, 14, 15, 16, 17], 
      [18, 19, 20, 21, 22, 23]]
result = np.vstack((v1, v2))
#矩阵水平拼接np.hstack((v1,v2))
result=np.hstack((v1,v2))
#Numpy读取数据np.genfromtxt
```
### NumPy - 广播
1. 术语广播是指 NumPy 在算术运算期间处理不同形状的数组的能力。 对数组的算术运算通常在相应的元素上进行。 如果两个阵列具有完全相同的形状，则这些操作被无缝执行。
2. 如果两个数组的维数不相同，则元素到元素的操作是不可能的。 然而，在 NumPy 中仍然可以对形状不相似的数组进行操作，因为它拥有广播功能。 较小的数组会广播到较大数组的大小，以便使它们的形状可兼容。
如果满足以下规则，可以进行广播：
* ndim较小的数组会在前面追加一个长度为 1 的维度。
* 输出数组的每个维度的大小是输入数组该维度大小的最大值。
* 如果输入在每个维度中的大小与输出大小匹配，或其值正好为 1，则在计算中可它。
* 如果输入的某个维度大小为 1，则该维度中的第一个数据元素将用于该维度的所有计算。  
如果上述规则产生有效结果，并且满足以下条件之一，那么数组被称为可广播的。
* 数组拥有相同形状。
* 数组拥有相同的维数，每个维度拥有相同长度，或者长度为 1。
* 数组拥有极少的维度，可以在其前面追加长度为 1 的维度，使上述条件成立。
### 形态学转换
形态学转换原理：一般情况下对二值化图像进行操作。需要两个参数，一个是原始图像，第 二个被称为结构化元素或者核，它是用来决定操作的性质的。基本操作为腐蚀和膨胀，他们 的变体构成了开运算，闭运算，梯度等.
1. 腐蚀
* 把前景物体的边界腐蚀掉，但是前景仍然是白色的。卷积核沿着图像滑动，如果与卷积核对 应的原图像的所有像素值都是1，那么中心元素就保持原来的像素值，否则就变为零。根据卷 积核的大小靠近前景的所有像素都会被腐蚀掉（变为0），所以前景物体会变小，整幅图像的 白色区域会减少。这对于去除白噪音很有用，也可以用来断开两个连在一块的物体。
2. 膨胀 
* 与腐蚀相反，与卷积核对应的原图像的像素值中只要有一个是1，中心元素的像素值就是1。 所以这个操作会增加图像中白色区域（前景）。一般在去噪音时先腐蚀再膨胀，因为腐蚀再 去掉白噪音的同时，也会使前景对象变小，所以我们再膨胀。这时噪音已经被去除，不会再 回来了，但是前景还在并会增加，膨胀也可以用来连接两个分开的物体。
3. 开运算
*  先进行腐蚀再进行膨胀就叫做开运算。被用来去除噪音，函数可以使用cv2.morphotogyEx()
4. 闭运算
* 先膨胀再腐蚀。被用来填充前景物体中的小洞，或者前景上的小黑点。
5. 形态学梯度
* 其实就是一幅图像膨胀与腐蚀的差别。 结果看上去就像前景物体的轮廓。
6. 礼帽 
* 原始图像与进行开运算之后得到的图像的差。
7. 黑帽 
* 进行闭运算之后得到的图像与原始图像的差。
# 2018-7-26
今天准备练习一下OpenCV的小例子，复习相关知识，学习tensorflow。
# 2018-7-27
继续学习tensorflow，把项目跑起来。
### 理解TensorFlow
### TensorFlow 不是一个标准的 Python 库
Python 和 TensorFlow 之间的关系可以类比 Javascript 和 HTML 之间的关系。Javascript 是一种全功能的编程语言，可以做各种美妙的事情。HTML 是用于表示某种类型的实用计算抽象（此处指可由 Web 浏览器呈现的内容）的框架。Javascript 在交互式网页中的作用是组装浏览器看到的 HTML 对象，然后在需要时通过将其更新为新的 HTML 来与其交互。<br>
与 HTML 类似，TensorFlow 是用于表示某种类型的计算抽象（称为「计算图」）的框架。但我们用 Python 操作 TensorFlow 时，我们用 Pyhton 代码做的第一件事就是构建计算图。一旦完成，我们做的第二件事就是与它进行交互（启动 TensorFlow 的「会话」）。但重要的是，要记住计算图不在变量内部；而是处在全局命名空间中。<br>
### 第一个关键抽象：计算图
什么是计算图？它本质上是一个全局数据结构：是一个有向图，用于捕获有关如何计算的指令。计算图只包含计算步骤；不包含结果。
### 第二个关键抽象： 会话
会话的作用是处理内存分配和优化，使我们能够实际执行由计算图指定的计算。你可以将计算图想象为我们想要执行的计算的「模版」：它列出了所有步骤。为了使用计算图，我们需要启动一个会话，它使我们能够实际地完成任务；
# 2018-7-28
熟悉PDF-PRJ项目，把它运行起来。
# 2018-7-30
学习tensorflow，熟悉训练模型，读懂PDF-PRJ项目的训练模型。
# 2018-7-31
使用OpenCV切出印章，并把印章上的字拉直。复习OpenCV。







